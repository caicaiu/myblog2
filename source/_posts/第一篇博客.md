---
title: rabbitMq
date: 2022-09-25 09:37:34
tags: rabbitMQ
---

 RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。

<!--more--> 

# 1.什么是消息队列

在两个应用传输过程中保存消息的容器

![image-20220904190919953](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220904190919953.png)



# 2.为什么使用

先看一下消息队列的使用场景

## 解耦

> 在A系统中，要分发消息到不同的子系统上，比如B,C,D，如果我们的D系统不需要了，而又增加了一个E系统需要A系统的消息。在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！

**使用MQ解决**
A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。

![image-20220904191714838](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220904191714838.png)

**总结**：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。

## 异步

> A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统依次写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。



![img](https://pic3.zhimg.com/v2-b7ab6fadf33792f9c278e03da85e3282_b.jpg)



一般互联网类的企业，对于用户直接的操作，**一般要求是每个请求都必须在 200 ms 以内完成**，对用户几乎是无感知的。

如果**使用 MQ**，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，**，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。**，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！

> 也就是说我们A系统接收到请求后，直接发送到队列中，只关注MQ耗时即可

![img](https://pic2.zhimg.com/v2-1cc1f94c32b602678876978ecff90175_b.jpg)

## 削峰

每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。

一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。

但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。



**如果使用 MQ**，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。**A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok**，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。



![img](https://pic3.zhimg.com/v2-cc3b9a973098a4db811edc3815e72c8a_b.jpg)



这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。

# 3. 消息队列的优缺点

优点上面已经说了，就是**在特殊场景下有其对应的好处**，**解耦**、**异步**、**削峰**。

缺点有以下几个：

+ 系统可用性降低
	大家想想一下，上面的说解耦的场景，本来A系统的哥们要把系统关键数据发送给BC系统的，现在突然加入了一个MQ了，现在BC系统接收数据要通过MQ来接收。
	但是大家有没有考虑过一个问题，万一MQ挂了怎么办?这就引出一个问题，加入了MQ之后，系统的可用性是不是就降低了?
	因为多了一个风险因素：MQ可能会挂掉。只要MQ挂了，数据没了，系统运行就不对了。

+ 系统复杂度提高

	本来我的系统通过接口调用一下就能完事的，但是加入一个MQ之后，需要考虑消息重复消费、消息丢失、甚至消息顺序性的问题

	为了解决这些问题，又需要引入很多复杂的机制，这样一来是不是系统的复杂度提高了。

+ 数据一致性问题

	本来好好的，A系统调用BC系统接口，如果BC系统出错了，会抛出异常，返回给A系统让A系统知道，这样的话就可以做回滚操作了

	但是使用了MQ之后，A系统发送完消息就完事了，认为成功了。而刚好C系统写数据库的时候失败了，但是A认为C已经成功了?这样一来数据就不一致了。



# 4. RabbitMQ简介

## 1. RabbitMQ 的概念  

 RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。
消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。

![img](https://upload-images.jianshu.io/upload_images/5015984-066ff248d5ff8eed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/401/format/webp)

## 2. 四大核心概念  

**生产者** 产生数据发送消息的程序是生产者 

**交换机**

+ 交换机是 `RabbitMQ` 非常重要的一个部件，一方面它**接收**来自**生产者**的**消息**，另一方面它将**消息推送到队列**中。
+ 交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到**特定队列**还是推送到**多个队列**，或者是把**消息丢弃**。

**队列** 

+ 队列是 `RabbitMQ` 内部使用的一种数**据结构**，尽管消息流经 `RabbitMQ` 和应用程序，但它们**只能存储**在队列中。
+ 队列仅受主机的内存和磁盘限制的约束，本质上是一个大的**消息缓冲区**。
+ 许多生产者可以将消息发送到一个队列，许多消费者也可以尝试从一个队列接收数据。

**消费者** 

+ 消费者大多时候是一个**等待接收消息**的程序。
+ 消费者和消息中间件很多时候并不在同一机器上。
+ 同一个应用程序既可以是生产者又可以是消费者。

## 3. RabbitMQ 核心部分 

> + Hello Wold  简单模式
> + Work queues 工作队列模式
> + Publish/Subscribe 发布订阅模式
> + Routing  路由模式
> + Topics  主题模式
> + Publisher Confirms  发布确认模式

![image-20220824103957451](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220824103957451.png)

## 4. 工作原理 

![image-20220824115154768](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220824115154768.png)

+ **Broker**   接收和分发消息的应用
+ **Virtual host**
	虚拟主机，出于多租户和安全因素设计的，把 AMQP(高级消息队列协议) 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等
+ Connection
	**publisher／consumer 和 broker 之间的 TCP 连接，通过Channel信道传输消息**
+ Channel
	如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。**Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯**，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的Channel 极大减少了操作系统建立 TCP connection 的开销
+ Exchange
	**message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。**常用的类型有direct (point-to-point)、topic (publish-subscribe)、 fanout (multicast)
+ Queue
	消息最终被送到这里等待 consumer 取走
+ Binding
	**exchange 和 queue 之间的虚拟连接**，binding 中可以包含 routing key，Binding 信息被保
	存到 exchange 中的查询表中，用于 message 的分发依据

# 5. Rabbit mq的安装

## 1. 下载[rabbitmq](https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.16)

**注意：我们的机器是Linux 7 所以我们必须下载有 el7 的版本**
![image-20220824110513492](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220824110513492.png)

## 2. 下载[erlang](https://packagecloud.io/rabbitmq/erlang)

一定要查看官网查看erlang相对应的安装包

![image-20220824110626362](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220824110626362.png)

赋值命令去linux中执行

## 3. 下载socat

由于是[内存管理](https://so.csdn.net/so/search?q=内存管理&spm=1001.2101.3001.7020)
任何版本都支持
复制一下命令到Linux 运行下载即可

```bash
wget http://mirror.centos.org/centos/7/os/x86_64/Packages/socat-1.7.3.2-2.el7.x86_64.rpm
```

## 4. 安装顺序

![在这里插入图片描述](https://img-blog.csdnimg.cn/a54a8605c95b48b2bc9aa4b85765dc1c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVG9CZUJldHRlclBlcnNvbk9uZQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

1. 依次执行一下命令

	```
	rpm -ivh erlang-21.3-1.el7.x86_64.rpm
	yum install socat -y
	rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm
	```

	1. 先安装erlang
	2. 再安装socat
	3. 最后安装rabbitMQ


## 5. 查看rabbitmq是否成功

输入以下命令

```bash
sytemctl status rabbitmq-server
```

如果出现表示成功
![在这里插入图片描述](https://img-blog.csdnimg.cn/bc156249e6834f58a12db0bf428f2844.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVG9CZUJldHRlclBlcnNvbk9uZQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

## 6. 开启rabbitmq服务

```bash
systemctl start rabbitmq-server
```

## 7. 设置RabbitMQ自启动和服务

+ 设置rabbitmq开机自启动

	```
	chkconfig rabbitmq-server on
	```

+ 启动rabbitmq服务

	```
	/sbin/service rabbitmq-server start 
	```

+ 查看rabbitmq服务状态

	```
	/sbin/service rabbitmq-server status
	```

+ 停止rabbitmq服务

	```
	/sbin/service rabbitmq-server stop
	```

	

## 7. 开启web界面

1. 先暂停rabbitmq界面

	```
	/sbin/service rabbitmq-server stop
	```

2. 查看是否已经关闭

	```
	/sbin/service rabbitmq-server status
	```

	![image-20220824111224144](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220824111224144.png)

3. 下载web服务界面

	```
	rabbitmq-plugins enable rabbitmq_management
	```

4. 启动rabibitmq

	```
	/sbin/service rabbitmq-server start
	```

5. 关闭防火墙

  ```
systemctl stop firewalld  # 停止或开放端口 firewall-cmd --permanent --add-port=15672/tcp 
#刷新
firewall-cmd --reload
  ```

6. windows访问

	```
	 http://ip地址:15672
	```

	> 默认账户密码：guest

7. 需要授权
	![image-20220824111644574](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220824111644574.png)

## 8. 为web界面添加用户和授权

1. 创建账号 

	```
	rabbitmqctl add_user admin 123 
	```

2. 设置用户角色（授权）

	```
	rabbitmqctl set_user_tags admin administrator
	```

3. 设置用户权限

	```
	rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"
	```

	  用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限 当前用户和角色 rabbitmqctl list_users 

4. 查看当前用户和授权信息

	```
	rabbitmqctl list_users
	```

5. 利用 admin 用户登录 
	![image-20220824112444957](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220824112444957.png)

## 9. 关闭web界面

关闭应用的命令为

```
 rabbitmqctl stop_app 
```

清除的命令

```
rabbitmqctl reset
```

重新启动命令为 

```
rabbitmqctl start_app
```

# 6. 核心一(Hello World）

## 1. 创建Springboot工程

## 2. 引入依赖

```xml
<dependencies>
<!--rabbitmq 依赖客户端-->
	<dependency>
		<groupId>com.rabbitmq</groupId>
		<artifactId>amqp-client</artifactId>
		<version>5.8.0</version>
	</dependency>
<!--操作文件流的一个依赖-->
	<dependency>
		<groupId>commons-io</groupId>
		<artifactId>commons-io</artifactId>
		<version>2.6</version>
		</dependency>
</dependencies>
    !--指定 jdk 编译版本-->
<build>
	<plugins>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-compiler-plugin</artifactId>
			<configuration>
				<source>8</source>
				<target>8</target>
			</configuration>
		</plugin>
	  </plugins>
</build>
```

## 3. 创建生产者

```java
package com.example.rabbitmq.helloworld;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.Queue;
import java.util.concurrent.TimeoutException;

/**
 * 生产者
 */
public class Producer {

    //创建一个消息队列，指定名称
    public static final String QUEUEN_HELLO = "hello";

    //生产消息队列
    public static void main(String[] args) throws IOException, TimeoutException {
        //获取连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置连接工厂的ip地址
        factory.setHost("192.168.200.130");
        //登录
        factory.setUsername("admin");
        factory.setPassword("123");

        //获取一个连接对象
        Connection connection = factory.newConnection();
        //创建一个链
        Channel channel = connection.createChannel();

        /**
         * 生成一个队列
         * 1.队列名称
         * 2.队列里面的消息是否持久化 默认消息存储在内存中
         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费
         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除
         * 5.其他参数
         */
        channel.queueDeclare(QUEUEN_HELLO,false,false,false,null);
        String message="hello world";

        /**
         * 发送一个消息
         * 1.发送到那个交换机 “” 是默认交换机
         * 2.路由的 key 是哪个 交换机和队列绑定的key
         * 3.其他的参数信息
         * 4.发送消息的消息体
         */
        channel.basicPublish("",QUEUEN_HELLO,null,message.getBytes());
        System.out.println("消息发送完毕");



    }

}

```

## 4. 查看消息是否发送成功

![image-20220824121246036](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220824121246036.png)

## 5. 创建消费者

```JAVA
class Consumer {
    private final static String QUEUE_NAME = "hello";

    public static void main(String[] args) throws Exception {
        //获取连接对象工厂
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("192.168.200.130");
        factory.setUsername("admin");
        factory.setPassword("123");
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        System.out.println("等待接收消息.........");
        //推送的消息如何进行消费的接口回调
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody());
            System.out.println(message);
        };
        //取消消费的一个回调接口 如在消费的时候队列被删除掉了
        CancelCallback cancelCallback = (consumerTag) -> {
            System.out.println("消息消费被中断");
        };
        /**
         * 消费者消费消息
         * 1.消费哪个队列
         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答
         * 3.消费者未成功消费的回调
         */
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);
    }
}

```

## 6. 成功消费

![image-20220824121747029](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220824121747029.png)

# 7. 核心—(Work Queues）

工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。

##  3.1. 轮训分发消息   

> 生产者发送多个消息的时候，多个工作线程会平均处理这些消息，消息只能被处理一次

### 3.1.1 原理图

![image-20220827205232226](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220827205232226.png)

### 3.1.2 代码实现

#### 工作线程1

```java
/**
 * 工作线程1
 */
public class Work1 {

    public static final String QUEUEN_NAME = "hello";

    public static void main(String[] args) throws Exception {

        Channel channel = ConnectionUtils.getchannel();

        DeliverCallback deliverCallback = (s,delivery)->{

           //System.out.println(delivery.getBody()); 因为传送的是二进制，所以不能直接获取
            String message = delivery.getBody().toString();
            System.out.println(message);
        };

        //处理终端
        CancelCallback cancelCallback = s -> {
            System.out.println("队列被中断");
            
        };

        System.out.println("工作1接收消息");
        /**
         * 消费者消费消息
         * 1.消费哪个队列
         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答
         * 3.消费者未成功消费的回调
         */
        channel.basicConsume(QUEUEN_NAME, false, deliverCallback,cancelCallback );


    }

}
```

#### 工作线程2

```java
public class Work2 {


    public static final String QUEUEN_NAME = "hello";

    public static void main(String[] args) throws Exception {

        Channel channel = ConnectionUtils.getchannel();

        DeliverCallback deliverCallback = (s, delivery)->{

            //System.out.println(delivery.getBody()); 因为传送的是二进制，所以不能直接获取
            String message = delivery.getBody().toString();
            System.out.println(message);
        };

        //处理终端
        CancelCallback cancelCallback = s -> {
            System.out.println("队列被中断");

        };

        System.out.println("工作2接收消息");
        /**
         * 消费者消费消息
         * 1.消费哪个队列
         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答
         * 3.消费者未成功消费的回调
         */
        channel.basicConsume(QUEUEN_NAME, false, deliverCallback,cancelCallback );


    }

}

```

#### 生产者

```java
/**
 * 生产者
 */
public class Producer {

    public static final String QUEUEN_NAME = "hello";

            public static void main(String[] args) throws Exception {
                try {
                    Channel channel = ConnectionUtils.getchannel();
                    /**
                     * 生成一个队列
                     * 1.队列名称
                     * 2.队列里面的消息是否持久化 默认消息存储在内存中
                     * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费
                     * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除
                     * 5.其他参数
                     */
                    channel.queueDeclare(QUEUEN_NAME, false, false, false, null);
                    channel.queueDeclare(QUEUEN_NAME, false, false, false, null);
                    //从控制台当中接受信息
                    Scanner scanner = new Scanner(System.in);
                    while (scanner.hasNext()) {
                        String message = scanner.next();

                        /**
                         * 发送一个消息
                         * 1.发送到那个交换机
                         * 2.路由的 key 是哪个
                         * 3.其他的参数信息
                         * 4.发送消息的消息体*/
                        channel.basicPublish("", QUEUEN_NAME, null, message.getBytes());
                        System.out.println("发送消息完成:" + message);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

```

## 3.2. 消息应答   

### 3.2.1. 概念   

**如果消费者处理一个长任务只完成一部分他死机了，那么之前接收的消息就随着他的消失而消失**

 为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制

消息应答就是:**消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。** 

### 3.2.2. 自动应答  

 **消息发送后立即被认为已经传送成功，但是仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用**

> 因为如果自动应答下面还有代码，代码出现异常，那么消息也会丢失

### 3.2.3 手动应答

自己动手应答。

### 3.2.4. 消息应答的方法   

+ Channel.basicAck(用于肯定确认)  RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了
+ Channel.basicNack(用于否定确认)  
+ Channel.basicReject(用于否定确认)  与 Channel.basicNack 相比少一个参数 不处理该消息了直接拒绝，可以将其丢弃了

### 3.2.5. Multiple 的解释   

![image-20220827213352603](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220827213352603.png)

**手动应答的好处是可以批量应答并且减少网络拥堵**   multiple 的 true 和 false 代表不同意思 **true 代表批量应答** channel 上未应答的消息 比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答 false 同上面相比 只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应

##### 批量应答

![image-20220827213442651](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220827213442651.png)

##### 自动应答

![image-20220827213450374](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220827213450374.png)

### 3.2.6. 消息自动重新入队

 如果**消费者**由于某些原因**失去连接**(其通道已关闭，连接已关闭或 TCP 连接丢失)，**导致消息 未发送 ACK 确认**，RabbitMQ 将了解到消息未完全处理，并将**对其重新排队**。如果此时其他消费者 可以处理，它将很快将其**重新分发给另一个消费者**。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息。
![image-20220827213753256](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220827213753256.png)



### 3.2.6. 消息手动应答代码

 **默认消息采用的是自动应答**，所以我们要想实现消息消费过程中不丢失，需要把自动应答改 为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。

##### 消息生产者

```java
public class Task02 {

    public static final String ACK_QUEUE_NAME = "ack_queue";

    public static void main(String[] args) throws Exception {

        Channel channel = RabbitMqUtils.getChannel();

        channel.queueDeclare(ACK_QUEUE_NAME, false, false, false, null);

        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNext()) {

            String message = scanner.next();

            channel.basicPublish("", ACK_QUEUE_NAME, null, message.getBytes("UTF-8"));

            System.out.println("发送消息完成" + message);

        }
    }
}

```

##### 消费者c1

```java
public class Worker01 {


    public static final String ACK_QUEUE_NAME = "ack_queue";

    public static void main(String[] args) throws Exception {

        Channel channel = RabbitMqUtils.getChannel();

        System.out.println("c1等待接收消息处理时间较短");

        //消息回调接口
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            SleepUtils.sleep(1);
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("接收的消息是：" + message);

            //手动应答
            /**
             * 1.消息的标记 
             * 2.是否批量应答
             */
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        };

        //取消消费的一个回调接口 如在消费的时候队列被删除掉了

        CancelCallback cancelCallback = (consumerTag) -> {
            System.out.println("消息消费被中断");
        };

        //采用手动应答
        //消息在手动应答时是不丢失，放回队列中重新消费
        boolean autoAck = false;
        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);

    }
}

```

##### 消费者c2

```java
public class Worker02 {


    public static final String ACK_QUEUE_NAME = "ack_queue";

    public static void main(String[] args) throws Exception {

        Channel channel = RabbitMqUtils.getChannel();

        System.out.println("c2等待接收消息处理时间较长");

        //消息回调接口
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            SleepUtils.sleep(30);
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("接收的消息是：" + message);

            //手动应答
            /**
             * 1.消息的标记
             * 2.是否批量应答
             */
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        };

        //取消消费的一个回调接口 如在消费的时候队列被删除掉了

        CancelCallback cancelCallback = (consumerTag) -> {
            System.out.println("消息消费被中断");
        };

        //采用手动应答
        //消息在手动应答时是不丢失，放回队列中重新消费
        boolean autoAck = false;
        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);

    }
}


```

##### 手动应答效果

正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理

在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是 由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，**C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了**

![image-20220827215800070](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220827215800070.png)

## 3.3. RabbitMQ 持久化

### 3.3.1. 概念  

> 保障发送过来的消息不丢失

 如何保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 **RabbitMQ 退出**或由于**某种原因崩溃**时，**它忽视队列 和消息**，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需**要将队列和消息都标 记为持久化**。 

### 3.3.2. 队列如何实现持久化   

之前我们创建的队列都是非持久化的，**rabbitmq 如果重启的话，该队列就会被删除掉**，如果 要**队列实现持久化** 需要在声明队列的时候**把 durable 参数设置为持久化** 但是需要注意的就是**如果之前声明的队列不是持久化的**，需要**把原先队列先删除**，或者**重新 创建一个持久化的队列**，不然就会出现错误 以下为控制台中持久化与非持久化队列的 UI 显示区



队列实现持久化代码（生产者中指定）

![image-20220828113140394](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220828113140394.png)



![image-20220828110801910](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220828110801910.png)

这个时候即使重启 rabbitmq 队列也依然存在

### 3.3.3. 消息持久化

要想让消息实现持久化需要在消息生产者修改代码，**MessageProperties.PERSISTENT_TEXT_PLAIN 添加这个属性**

```java
// 设置持久化消息，将信息保存在磁盘上
channel.basicPublish("",TASK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes("UTF-8"));
```

将消息标记为持久化**并不能完全保证不会丢失消息**。
尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候，但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。

### 3.3.4. 不公平分发 

对于消费者，能者多劳

##### 生产者

> 声明队列后指定

```java
public static void main(String[] args) throws Exception{
        //获取链
        Channel channel = ConnectionUtils.getchannel();
        //创建队列
        //队列是否持久,
        channel.queueDeclare(QUEUE_HELLO,true,false,false,null);

        //设置不公平分发
        /*channel.basicQos(1);*/
        Scanner scanner = new Scanner(System.in);

        //发送消息
        while(scanner.hasNext()){
            String message = scanner.next();
            channel.basicPublish("",QUEUE_HELLO, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());
            System.out.println("消息发送成功");
        }
    }
```

##### 消费者

```java
   public static void main(String[] args) throws  Exception{
        //获取链
        Channel channel = ConnectionUtils.getchannel();

        DeliverCallback deliverCallback = (s, delivery)->{

            //System.out.println(delivery.getBody()); 因为传送的是二进制，所以不能直接获取
            String message = new String(delivery.getBody(),"UTF-8");
            System.out.println(message);

            //工作1 睡眠1秒

            try {
                Thread.sleep(1000*1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            //手动应答
            /**
             * 1，是消息的标记
             * 2. 是否批量处理
             */
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
        };

        //处理终端
        CancelCallback cancelCallback = s -> {
            System.out.println("队列被中断");

        };
        System.out.println("工作线程1正在接收消息");
		//不公平分配
        channel.basicQos(1);
        //消费
        /**
         * 1. 消费的队列
         * 2.是否自动应答，
         * 3.成功回调函数
         * 4. 失败回调函数
         */
        channel.basicConsume(QUEUE_HELLO,false,deliverCallback,cancelCallback);



    }
```

### 3.3.5. 预取值

在消费上指定每个工作线程指定处理的个数，如果处理完后，那么就会处理下一个

#### 生产者

```java
public class PreProducer {

    public static final String QUEUE_WORK = "work";

    public static void main(String[] args) throws Exception{
        //获取链
        Channel channel = ConnectionUtils.getchannel();

        //创建队列，队列支持持久化
        channel.queueDeclare(QUEUE_WORK,true,false,false,null);

        //发消息
        Scanner scanner = new Scanner(System.in);

        while(scanner.hasNext()){
            //输入消息
            String message = scanner.next();
            //发送消息
            channel.basicPublish("",QUEUE_WORK, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes("UTF-8"));
            }
    }

}

```

#### 消费者

```java
public class PreWork01 {

    public static final String QUEUE_WORK = "work";

    public static void main(String[] args) throws Exception{
        //连接
        Channel channel = ConnectionUtils.getchannel();
        DeliverCallback deliverCallback = (s,message)->{
            String messages = new String(message.getBody());
            System.out.println("取值为::"+messages);
            //手动应答
            channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
        };

        CancelCallback cancelCallback = s->{
            System.out.println("消息处理失败");
        };

        System.out.println("线程1等待接收信息");
        //设置欲取值,处理3个
        channel.basicQos(3);

        //消费消息
        channel.basicConsume(QUEUE_WORK,false,deliverCallback,cancelCallback);

    }
}
```

# 8. 核心—(发布确认 )

## 4.1. 发布确认原理   

> 生产者和队列之间的确认信息

生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消 息都将会被**指派一个唯一的 ID(从 1 开始)**，一旦消息**被投递到所有匹配的队列之后**，**broker 就会 发送一个确认给生产者**(**包含消息的唯一 ID**)，这就使得生产者知道消息已经正确到达目的队列了， 如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产 者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。 confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道 返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方 法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息

## 4.2. 发布确认的策略

### 4.2.1. 开启发布确认的方法  

 发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布 确认，都需要在 channel 上调用该方法

声明队列后使用

```
channel.confirmSelect();
```

### 4.2.2. 单个确认发布

发布一条，确认一条，同步确认发布的方式
缺点是发布速度慢，会有阻塞

```java
public static void publishMessageIndividually() throws Exception {
	try (Channel channel = RabbitMqUtils.getChannel()) {
		String queueName = UUID.randomUUID().toString();
		channel.queueDeclare(queueName, false, false, false, null);
		//开启发布确认
		channel.confirmSelect();
		long begin = System.currentTimeMillis();
		for (int i = 0; i < MESSAGE_COUNT; i++) {
			String message = i + "";
			channel.basicPublish("", queueName, null, message.getBytes());
			//服务端返回 false 或超时时间内未返回，生产者可以消息重发
			boolean flag = channel.waitForConfirms();
			if(flag){
				System.out.println("消息发送成功");
			}
		}
		long end = System.currentTimeMillis();
		System.out.println("发布" + MESSAGE_COUNT + "个单独确认消息,耗时" + (end - begin) + 
		"ms");
	} 
}

```



### 4.2.3. 批量确认发布  

与单个发布确认相比，效率提高了
缺点是当发生问题时，不能精准定位问题

```java
public static void publishMessageBatch() throws Exception {
	try (Channel channel = RabbitMqUtils.getChannel()) {
		String queueName = UUID.randomUUID().toString();
		channel.queueDeclare(queueName, false, false, false, null);
		//开启发布确认
		channel.confirmSelect();
		//批量确认消息大小
		int batchSize = 100;
		//未确认消息个数
		int outstandingMessageCount = 0;
		long begin = System.currentTimeMillis();
		for (int i = 0; i < MESSAGE_COUNT; i++) {
			String message = i + "";
			channel.basicPublish("", queueName, null, message.getBytes());
			outstandingMessageCount++;
			if (outstandingMessageCount == batchSize) {
                //确认发布
				channel.waitForConfirms();
				outstandingMessageCount = 0;
			}
		}
		//为了确保还有剩余没有确认消息 再次确认
		if (outstandingMessageCount > 0) {
			channel.waitForConfirms();
		}
		long end = System.currentTimeMillis();
		System.out.println("发布" + MESSAGE_COUNT + "个批量确认消息,耗时" + (end - begin) + 
		"ms");
	} 
}

```



### 4.2.4. 异步确认发布

 **异步确认**虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说，他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功，下面就让我们来详细讲解异步确认是怎么实现的

![在这里插入图片描述](https://img-blog.csdnimg.cn/498db7504d074db1919b1585887c2b78.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU0g6IOh6bmP6aOe,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

##### 生产者

```java
public static void publishMessageAsync() throws Exception {
    
	
   try (Channel channel = RabbitMqUtils.getChannel()) {//创建一个信道
		String queueName = UUID.randomUUID().toString();
        //声明队列
		channel.queueDeclare(queueName,false, false, false, null);
		//开启发布确认
		channel.confirmSelect();
		/**
		* 线程安全有序的一个哈希表，适用于高并发的情况
		* 1.轻松的将序号与消息进行关联
		* 2.轻松批量删除条目 只要给到序列号
		* 3.支持并发访问
		*/
		ConcurrentSkipListMap<Long, String> outstandingConfirms = new 
		ConcurrentSkipListMap<>();
		/**
		* 消息确认成功 回调函数
		* 1.消息序列号
		* 2.true 可以确认小于等于当前序列号的消息
		* false 确认当前序列号消息
		*/
		ConfirmCallback ackCallback = (sequenceNumber, multiple) -> {
			// 如果是批量的
			if (multiple) {
				//返回的是小于等于当前序列号的未确认消息 是一个 map
				ConcurrentNavigableMap<Long, String> confirmed = 
				outstandingConfirms.headMap(sequenceNumber, true);
				//清除该部分未确认消息
				confirmed.clear();
			}else{
				//只清除当前序列号的消息
				outstandingConfirms.remove(sequenceNumber);
			}
		};
		/**
		* 消息确认失败 回调函数
		*/
		ConfirmCallback nackCallback = (sequenceNumber, multiple) -> {
			String message = outstandingConfirms.get(sequenceNumber);
			System.out.println("发布的消息"+message+"未被确认，序列号"+sequenceNumber);
		};
		/**
		* 添加一个异步确认的监听器
		* 1.确认收到消息的回调
		* 2.未收到消息的回调
		*/
		channel.addConfirmListener(ackCallback, null);
		long begin = System.currentTimeMillis();
		for (int i = 0; i < MESSAGE_COUNT; i++) {
			String message = "消息" + i;
			/**
			* channel.getNextPublishSeqNo()获取下一个消息的序列号
			* 通过序列号与消息体进行一个关联
			* 全部都是未确认的消息体
			*/
			outstandingConfirms.put(channel.getNextPublishSeqNo(), message);
			channel.basicPublish("", queueName, null, message.getBytes());
		}
		long end = System.currentTimeMillis();
		System.out.println("发布" + MESSAGE_COUNT + "个异步确认消息,耗时" + (end - begin) + 
		"ms");
	} 
}

```

### 4.2.5. 如何处理异步未确认消息   

最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。

> 使用ConcurrentSkipListMap这两个来处理，如果成功确认了，那么就删除该队列，如果还没有确认，那么就重新赋值

### 4.2.6. 以上 3 种发布确认速度对比

**单独发布消息**
同步等待确认，简单，但吞吐量非常有限。
**批量发布消息**
批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。
**异步处理**
最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些

# 9. 核心—(交换机)

## 5.1.1. 交换机的作用

将消息传达给多个消费者。这种模式
称为 ”发布/订阅”

RabbitMQ 消息传递模型的核心思想是: **生产者生产的消息从不会直接发送到队列**。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中

相反，**生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。**交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定

## 5.1.2. Exchanges 的类型 

### 其他类型

Exchange的类型
直接（direct）
主题（topic）
标题（headers）
扇出（fanout）
无名（默认类型）

### 无名类型

在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。 

![image-20220828164351398](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220828164351398.png)

第一个参数**是交换机的名称**。空字符串**表示默认或无名称交换机**：消息能路由发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的

## 5.2. 临时队列

无名称，不持久化

// 创建临时队列

```java
String queueName = channel.queueDeclare().getQueue();
```

## 5.3 绑定

binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系

路由key是交换机和队列之间的key

## 5.4. Fanout 

### 5.4.1. Fanout 介绍

> 只可以绑定一个

Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型

![image-20220828164656744](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220828164656744.png)

捆绑如下

![image-20220828164711522](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220828164711522.png)

#### 生产者

```java
/**
 * 发布者
 */
public class FanoutExchanger {
    //交换机名称
    private static final String EXCHANGE_NAME = "logs";

    public static void main(String[] args) throws Exception{
        //获取链
        Channel channel = ConnectionUtils.getchannel();

        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME,"fanout");

        Scanner scanner = new Scanner(System.in);
        //发布消息
        while (scanner.hasNext()){

            String message = scanner.next();
            //发布消息
            channel.basicPublish(EXCHANGE_NAME,"", null,message.getBytes());
        }

    }

}
```

#### 消费者

```java
    public static void main(String[] args) throws Exception {
        //自动生成一个消费者
        Channel channel = ConnectionUtils.getchannel();

        //声明一个交换机,跟生产者一样，并且指定交换机类型
        channel.exchangeDeclare(EXCHANGE_NAME,"fanout");

        //声明一个临时队列
        /*channel.queueDeclare(QUEUE_NAME,false,false,false,null);*/
        String queue = channel.queueDeclare().getQueue();

        //队列绑定交换机
        /*channel.queueBind(EXCHANGE_NAME,QUEUE_NAME,"");*/
        channel.queueBind(queue,EXCHANGE_NAME,"");

        System.out.println("C1正在接收消息");
        DeliverCallback deliverCallback = (s,message)->{

            String messages = new String(message.getBody());
            System.out.println("接收消息为"+messages);
            //手动应答
            channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
        };

        CancelCallback cancelCallback = s-> System.out.println("接收失败");

        //消费
        channel.basicConsume(queue,false,deliverCallback,cancelCallback);
    }
}

```



#### 结果

![image-20220828172943287](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220828172943287.png)

## 5.5 Direct

> 一个队列可以绑定多个路由key

多重绑定交换机

这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。

### 生产者

```java
package com.example.rabbitmq.exchanger.direct;

import com.example.rabbitmq.utils.ConnectionUtils;
import com.rabbitmq.client.Channel;

import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

/**
 * 生产者
 */
public class DirProducer {

    private static final String EXCHANGE_NAME = "logs2";

    public static void main(String[] args) throws Exception {
        //获取链
        Channel channel = ConnectionUtils.getchannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME, "direct");

        Map<String, String> map = new HashMap<>();
        map.put("err", "异常消息对应Q1");
        map.put("info", "异常消息对应Q2");
        map.put("warning", "异常消息对应Q3");

        //发送消息
        Set<Map.Entry<String, String>> entries = map.entrySet();
        for (Map.Entry<String, String> entry : entries) {
            //获取消息
            String key = entry.getKey();
            String message = entry.getValue();
            //发送消息
            channel.basicPublish(EXCHANGE_NAME,key,null,message.getBytes(StandardCharsets.UTF_8));
        }

    }

}

```

### 消费者

```java
package com.example.rabbitmq.exchanger.direct;

import com.example.rabbitmq.utils.ConnectionUtils;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

/**
 * 消费者
 */
public class DirWork01 {

    private static final String EXCHANGE_NAME = "logs2";

    public static void main(String[] args)throws Exception{
        //获取链
        Channel channel = ConnectionUtils.getchannel();

        //声明一个交换机,
        channel.exchangeDeclare(EXCHANGE_NAME,"direct");
        //声明绑定一个队列
        channel.queueDeclare("Q1",false,false,false,null);
        //绑定队列 "err"是队列和消费者的一个key
        channel.queueBind("Q1",EXCHANGE_NAME,"err");

        //成功响应消息
        DeliverCallback deliverCallback = (s,message)->{
            String messages = new String(message.getBody());
            System.out.println("成功访问"+messages);
        };

        //消费队列
        channel.basicConsume("Q1",true,deliverCallback,s->{} );


    }
}

```

### 消费者2

```java
import com.rabbitmq.client.DeliverCallback;
/**
 * 消费者
 */
public class DirWork02 {

    private static final String EXCHANGE_NAME = "logs2";

    public static void main(String[] args)throws Exception{
        //获取链
        Channel channel = ConnectionUtils.getchannel();

        //声明一个交换机,
        channel.exchangeDeclare(EXCHANGE_NAME,"direct");
        //声明绑定一个队列
        channel.queueDeclare("Q2",false,false,false,null);
        //绑定队列
        channel.queueBind("Q2",EXCHANGE_NAME,"info");
        //绑定另一个队列
        channel.queueBind("Q2",EXCHANGE_NAME,"warning");

        //成功响应消息
        DeliverCallback deliverCallback = (s,message)->{
            String messages = new String(message.getBody());
            System.out.println("成功访问"+messages);
        };

        //消费队列
        channel.basicConsume("Q2",true,deliverCallback,s->{} );


    }
}

```

## 5.6 Topic交换机

> 队列可以模糊匹配交换机的路由key

发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：“stock.usd.nyse”, “nyse.vmw”,
“quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。

在这个规则列表中，其中有两个替换符是大家需要注意的
***(星号)可以代替一个单词**
**#(井号)可以替代零个或多个单词**

当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了
如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了

> 相当于是模糊匹配

### 实例

![image-20220828190232721](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220828190232721.png)

![image-20220828190304322](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220828190304322.png)

### 实战

#### 生产者

```java
/**
 * 生产者
 */
public class ToPruducer {

    private static final String EXCHANGE_NAME = "logs3";

    public static void main(String[] args) throws Exception{
        //获取链
        Channel channel = ConnectionUtils.getchannel();
        //声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME,"topic");
        //发送消息
        Map<String,String> map = new HashMap<>();

        Map<String, String> bindingKeyMap = new HashMap<>();
        bindingKeyMap.put("quick.orange.rabbit","quick.orange.rabbit被队列 Q1Q2 接收到");
        bindingKeyMap.put("lazy.orange.elephant","lazy.orange.elephant被队列 Q1Q2 接收到");
        bindingKeyMap.put("quick.orange.fox","quick.orange.fox被队列 Q1 接收到");
        bindingKeyMap.put("lazy.brown.fox","lazy.brown.fox被队列 Q2 接收到");
        bindingKeyMap.put("quick.orange.fox"," quick.orange.fox被队列 Q1 接收到");
        bindingKeyMap.put("lazy.brown.fox ","lazy.brown.fox被队列 Q2 接收到");
        bindingKeyMap.put("lazy.pink.rabbit","lazy.pink.rabbit虽然满足两个绑定但只被队列 Q2 接收一次");
        bindingKeyMap.put("quick.brown.fox ","quick.brown.fox不匹配任何绑定不会被任何队列接收到会被丢弃");
        bindingKeyMap.put("quick.orange.male.rabbit ","quick.orange.male.rabbit 是四个单词不匹配任何绑定会被丢弃");
        bindingKeyMap.put("lazy.orange.male.rabbit ","lazy.orange.male.rabbit是四个单词但匹配 Q");

        Set<Map.Entry<String, String>> entries = bindingKeyMap.entrySet();
        for (Map.Entry<String, String> entry : entries) {
            channel.basicPublish(EXCHANGE_NAME,entry.getKey(),null,entry.getValue().getBytes(StandardCharsets.UTF_8));
            System.out.println("成功发送消息，key为:"+entry.getKey()+"value为：" +entry.getValue());
        }

    }

}
```

### 消费者

```java
/**
 * 消费者
 */
public class ToWork01 {

    private static final String EXCHANGE_NAME = "logs3";

    public static void main(String[] args)  throws Exception{
        Channel channel = ConnectionUtils.getchannel();
        channel.exchangeDeclare(EXCHANGE_NAME,"topic");
        //创建一个消息队列
        channel.queueDeclare("Q1",false,false,false,null);
        //队列绑定
        channel.queueBind("Q1",EXCHANGE_NAME,"*.orange.*");
        DeliverCallback deliverCallback = (s,message)->{
            String messages = new String(message.getBody());
            System.out.println(message.getEnvelope().getDeliveryTag()+"接收消息为： "+messages);
        };

        //接收消息
        channel.basicConsume("Q1",true,deliverCallback,s-> System.out.println("失败"));
    }
}

```

### 消费者2

```java
/**
 * 消费者
 */
public class ToWork02 {

    private static final String EXCHANGE_NAME = "logs3";

    public static void main(String[] args)  throws Exception{
        Channel channel = ConnectionUtils.getchannel();
        channel.exchangeDeclare(EXCHANGE_NAME,"topic");
        //创建一个消息队列
        channel.queueDeclare("Q2",false,false,false,null);
        //队列绑定
        channel.queueBind("Q2",EXCHANGE_NAME,"*.*.rabbit");
        channel.queueBind("Q2",EXCHANGE_NAME,"laze.#");
        DeliverCallback deliverCallback = (s,message)->{
            String messages = new String(message.getBody());
            System.out.println("接收消息为： "+messages);
        };

        //接收消息
        channel.basicConsume("Q2",true,deliverCallback,s-> System.out.println("失败"));
    }
}

```

# 10. 死信队列

## 基本概念

先从概念解释上搞清楚这个定义，死信，顾名思义就是**无法被消费的消息**，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，但**某些时候由于特定的原因导致 queue 中的某些消息无法被消费**，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。

应用场景:

为了保证**订单业务的消息数据不丢失**，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中
用户在商城下单成功并点击去支付后在指定时
间未支付时自动失效

## 死信的来源

+ 消息 TTL（存活时间） 过期
+ 队列达到最大长度(队列满了，无法再添加数据到 mq 中)
+ 消息被拒绝(basic.reject 或 basic.nack)并且不放回队列中 （requeue=false）

#### 消息TTl存活时间过期

> 开启消费者1，然后开启生产者，开启死信，然后关掉消费者1（让消息过期），那么就会转到死信下面去

##### 消费者

```java
public class Consumer01 {
    //普通交换机名称
    private static final String NORMAL_EXCHANGE = "normal_exchange";
    //死信交换机名称
    private static final String DEAD_EXCHANGE = "dead_exchange";
    //普通队列
    private static final String NORMAL_QUEUE = "normal_queue";
    //死信队列
    private static final String DEAD_QUEUE = "dead_queue";

    public static void main(String[] argv) throws Exception {
        Channel channel = ConnectionUtils.getchannel();
        //声明死信和普通交换机 类型为 direct
        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
        channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
        //死信队列绑定死信交换机与 routingkey
        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, "lisi");
        //正常队列绑定死信队列信息
        Map<String, Object> params = new HashMap<>();
        //正常队列设置死信交换机 参数 key 是固定值
        params.put("x-dead-letter-exchange", DEAD_EXCHANGE);
        //正常队列设置死信 routing-key 参数 key 是固定值
        params.put("x-dead-letter-routing-key", "lisi");
        params.put("x-max-length",6);

        channel.queueDeclare(NORMAL_QUEUE, false, false, false, params);
        //绑定普通的交换机与普通的队列
        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, "zhangsan");
        //绑定死信的交换机与死信的队列
        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, "lisi");
        System.out.println("等待接收消息.....");
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("Consumer01 接收到消息"+message);
            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
        };
        channel.basicConsume(NORMAL_QUEUE, false, deliverCallback, consumerTag -> {
        });
    }
}
```

##### 生产者

> 发送的时候指定过期时间

```java
public class DLProducer {

    //普通交换机名称
    private static final String NORMAL_EXCHANGE = "normal_exchange";

    public static void main(String[] args) throws Exception {
        Channel channel = ConnectionUtils.getchannel();
        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);

        //设置过期时间
        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration("10000").build();


        for (int i = 0; i < 11; i++) {
            String message = "info" +i;
            channel.basicPublish(NORMAL_EXCHANGE,"zhangsan",properties,message.getBytes());
            System.out.println("成功发送"+message);

        }
    }

}

```

##### 死信消费者

```java
public class DeadLetterWork {

    //死信队列
    private static final String DEAD_QUEUE = "dead_queue";
    public static void main(String[] argv) throws Exception {
        Channel channel = ConnectionUtils.getchannel();
        System.out.println("等待接收死信队列消息.....");
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println("Consumer02 接收死信队列的消息" + message);

        };
        channel.basicConsume(DEAD_QUEUE, false, deliverCallback, consumerTag -> {});
    }
}
```



#### 队列达到最大长度

1. 取消生产者的时间限制

2. 在消费者1中定义这个参数

	```
	params.put("x-max-length",6);
	```

3. 杀死消费者1，让消息堆积在队列上

4. 可以看到死信队列只能接收5个参数
	![image-20220829064550086](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220829064550086.png)



#### 消息被拒

在消费者中使用channel.basicReject方法来句首消息

```java
public class Consumer01 {
	//普通交换机名称
	private static final String NORMAL_EXCHANGE = "normal_exchange";
	//死信交换机名称
	private static final String DEAD_EXCHANGE = "dead_exchange";
	public static void main(String[] argv) throws Exception {
		Channel channel = RabbitUtils.getChannel();
		//声明死信和普通交换机 类型为 direct
		channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
		channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
		//声明死信队列
		String deadQueue = "dead-queue";
		channel.queueDeclare(deadQueue, false, false, false, null);
		//死信队列绑定死信交换机与 routingkey
		channel.queueBind(deadQueue, DEAD_EXCHANGE, "lisi");
		//正常队列绑定死信队列信息
		Map<String, Object> params = new HashMap<>();
		//正常队列设置死信交换机 参数 key 是固定值
		params.put("x-dead-letter-exchange", DEAD_EXCHANGE);
		//正常队列设置死信 routing-key 参数 key 是固定值
		params.put("x-dead-letter-routing-key", "lisi");
		String normalQueue = "normal-queue";
		channel.queueDeclare(normalQueue, false, false, false, params);
		channel.queueBind(normalQueue, NORMAL_EXCHANGE, "zhangsan");
		System.out.println("等待接收消息.....");
		DeliverCallback deliverCallback = (consumerTag, delivery) -> {
			String message = new String(delivery.getBody(), "UTF-8");
			if(message.equals("info5")){
				System.out.println("Consumer01 接收到消息" + message + "并拒绝签收该消息");
				//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中
				channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);
			}else {
				System.out.println("Consumer01 接收到消息"+message);
				channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
			}
		};
		boolean autoAck = false;
		channel.basicConsume(normalQueue, autoAck, deliverCallback, consumerTag -> {});
	} 
}

```

# 11. 延迟队列

## 1. 基本概念

> 指定消息的存亡时间

他相当于是消息TTL存活时间过期，也就是说延迟10秒中后，传入信息到死信队列中

## 2. 使用场景

1.订单在十分钟之内未支付则自动取消
2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。
3.用户注册成功后，如果三天内没有登陆则进行短信提醒。
4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。
5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议

![image-20220829064735915](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220829064735915.png)

## 3. 整合Springboot

### 1. 创建Springboot工程

### 2. 引入依赖

```xml
<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!--RabbitMQ 依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.47</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <!--swagger-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.9.2</version>
        </dependency>
        <!--RabbitMQ 测试依赖-->
        <dependency>
            <groupId>org.springframework.amqp</groupId>
            <artifactId>spring-rabbit-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>2.7.1</version>
        </dependency>
    </dependencies>
```

### 3. 修改配置文件 

```java
spring.rabbitmq.host=192.168.200.130
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=123
```

### 4. 配置Swagger类

```java
package com.example.rabbitspringboot.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    public Docket webApiConfig(){

        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("webApi")
                .apiInfo(webApiInfo())
                .select().build();
    }

    private ApiInfo webApiInfo(){
        return new ApiInfoBuilder()
                .title("rabbitmq 接口文档")
                .description("本文档描述了 rabbitmq 微服务接口定义")
                .version("1.0")
                .contact(new Contact("enjoy6288", "http://atguigu.com","1551388580@qq.com")).build();
    }
}



```

## 4. 延迟消息代码实现

### 实现的图

![image-20220829083053006](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220829083053006.png)

#### 队列配置

```java
/**
 * 消息队列的配合类
 */
@Configuration
public class RabbitMQConfig {

    //普通交换机
    public static final String X_EXCHANGE = "X";



    //死信交换机
    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";

    //普通队列
    public static final String QUEUE_A = "QA";
    public static final String QUEUE_B = "QB";

    //死信队列
    public static final String DEAD_LETTER_QUEUE = "QD";


    /**
     * 普通交换机
     * @return
     */
    @Bean("xExchange")
    public DirectExchange xExchange(){

        return new DirectExchange(X_EXCHANGE);
    }

    /**
     * 死信交换机
     * @return
     */
    @Bean("yExchange")
    public DirectExchange yExchange(){
        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);
    }

    //普通队列A
    @Bean("queueA")
    public Queue queueA(){
        //配置死信交换机
        Map<String, Object> args = new HashMap<>();
        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
        //声明当前队列的死信路由 key
        args.put("x-dead-letter-routing-key", "YD");
        //声明队列的 TTL 1秒
        args.put("x-message-ttl", 10000);

        return QueueBuilder.durable(QUEUE_A).withArguments(args).build();
    }

    @Bean("queueB")
    public Queue queueB(){
        Map<String,Object> args = new HashMap<>();
        //配置死信交换机
        args.put("x-dead-letter-exchange",Y_DEAD_LETTER_EXCHANGE);
        //配置死信交换机的key
        args.put("x-dead-letter-routing-key","YD");
        //配置过期时间  40秒
        args.put("x-message-ttl",40000);
        //创建一个队列，并且持久
        return QueueBuilder.durable(QUEUE_B).withArguments(args).build();
    }

    //配置死信队列
    @Bean("queueD")
    public Queue queueD(){
        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();
    }

    @Bean
    //绑定关系
    public Binding deadLetterBindingQD(@Qualifier("queueD") Queue queue, @Qualifier("yExchange") DirectExchange exchange){
        //将队列绑定到交换机并且设置他的key
        return BindingBuilder.bind(queue).to(exchange).with("YD");

    }

    //普通队列绑定
    @Bean
    public Binding  queueABindingXA(@Qualifier("queueA") Queue queue,@Qualifier("xExchange") DirectExchange exchange){
        return BindingBuilder.bind(queue).to(exchange).with("XA");

    }
    @Bean
    public Binding queueBBindingXB(@Qualifier("queueB") Queue queue,@Qualifier("xExchange") DirectExchange exchange){
        return BindingBuilder.bind(queue).to(exchange).with("XB");
    }




}

```

#### 生产者

```java
@RestController
@RequestMapping("ttl")
@Slf4j
public class TTLController {


    @Autowired
    private RabbitTemplate rabbitTemplate ;

    @GetMapping("/sendMsg/{message}")
    public void  sendMsg(@PathVariable String message){

        //打印日志
        log.info("当前时间为{}，发送的消息为{}",new Date().toString(),message);
        //发送消息
        rabbitTemplate.convertAndSend("X","XA","消息为"+message);
        rabbitTemplate.convertAndSend("X","XB","消息为"+message);

    }
}

```

#### 死信消费者

```java
@Slf4j
@Component
public class DeadLetterQueueConsumer {

    //队列名
    @RabbitListener(queues = "QD")
    public void receiveD(Message message, Channel channel) throws IOException {
        String msg = new String(message.getBody());
        log.info("当前时间：{},收到死信队列信息{}", new Date().toString(), msg);
    }
}

```

### 问题

不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然 后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？

### 优化

> 在声明队列的时候我们不指定时间，而是让生产者去指定消费时间

![image-20220829083315079](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220829083315079.png)

#### 队列配置

```java
  //普通队列C
    @Bean("queueC")
    public Queue queueC(){

        Map<String,Object> args = new HashMap<>();
        //配置死信交换机
        args.put("x-dead-letter-exchange",Y_DEAD_LETTER_EXCHANGE);
        //配置死信交换机的key
        args.put("x-dead-letter-routing-key","YD");
        return  QueueBuilder.durable(QUEUE_C).withArguments(args).build();
    }



@Bean
    public Binding queueCBindingXC(@Qualifier("queueC") Queue queue,@Qualifier("xExchange") DirectExchange directExchange){
        return  BindingBuilder.bind(queue).to(directExchange).with("XC");
    }
```

#### 生产者

```java
@GetMapping("sendExpirationMsg/{message}/{time}")
    public void sendMsgTime(@PathVariable String message,@PathVariable String time){




        //发送消息
        rabbitTemplate.convertAndSend("X","XC",message.getBytes(StandardCharsets.UTF_8),
                correlationData -> {correlationData.getMessageProperties().setExpiration(time);
                                      return correlationData;
        });

       /* rabbitTemplate.convertAndSend("X", "XC", message, new MessagePostProcessor() {
            @Override
            public Message postProcessMessage(Message message) throws AmqpException {
                return null;
            }
        });*/

        log.info("当前时间为{}，指定的时间是{}ms，发送的消息是{}",new Date().toString(),time,message);

    }
```



### 引出问题

延迟的时候，队列会进行排序，如果前一个队列20000ms，后一个队列2000ms，那么后一个队列就会等待前一个队列进行处理

,这不是我们想要的结果，所以我们为了解决这个问题，引入一个队列的插件

## 5. 基于插件的延迟队列

### 1. 安装插件

#### 1.下载插件

[插件下载地址]([Releases · rabbitmq/rabbitmq-delayed-message-exchange (github.com)](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases))

> 版本是3.8.8或9的

![image-20220829144557276](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220829144557276.png)

#### 2.拷贝到当前目录下

> 在usr目录下

```
/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins
```

执行命令

```
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
```

#### 3.成功安装

![image-20220829150250224](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220829150250224.png)

### 2. 代码架构图  

在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:

![image-20220829150333984](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220829150333984.png)

### 3.代码实现

#### 生产者

```java
@RestController
@RequestMapping("ttb")
@Slf4j
public class DelayedController {

    @Autowired
    RabbitTemplate rabbitTemplate;


    @GetMapping("sendMsg/{message}/{time}")
    public  void send(@PathVariable String message,@PathVariable Integer time){


      //发送消息
        rabbitTemplate.convertAndSend(RabbitMQConfig2.DELAYED_EXCHANGE_NAME,RabbitMQConfig2.DELAYED_ROUTING_KEY,message.getBytes(StandardCharsets.UTF_8),
                correlationData -> { correlationData.getMessageProperties().setDelay(time);
        return  correlationData;});

        log.info("当前时间为{}，延迟{}ms发送消息，消息为{}",new Date().toString(),time,message);
    }

}
```

#### 消费者

```java
@Component
@Slf4j
public class DelayedConsumer {


    @RabbitListener(queues = "delayed.queue")
    public void getMessage(Message message){
        String messages = new String(message.getBody());
        log.info("当前时间为{}，消息为：{}",new Date(),messages);
    }
}
```

#### 配置类

```java
@Configuration
public class RabbitMQConfig2 {

    public static final String DELAYED_QUEUE_NAME = "delayed.queue";
    public static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";
    public static final String DELAYED_ROUTING_KEY = "delayed.routingkey";

    //配置自定义交换机
    @Bean("customExchange")
    public CustomExchange customExchange(){
        Map<String,Object> args = new HashMap<>();
        args.put("x-delayed-type","direct");
        return new CustomExchange(DELAYED_EXCHANGE_NAME,"x-delayed-message",true,false,args);
    }
    //配置队列
    @Bean("queue")
    public Queue queue(){
        return new Queue(DELAYED_QUEUE_NAME);
    }

    //进行绑定
    @Bean
    public Binding binding(@Qualifier("queue") Queue queue,
                           @Qualifier("customExchange") CustomExchange customExchange){

        return BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();
    }

}
```

# 10 发布确认高级

## 1. 引入发布确认高级

在生产环境中由于一些不明原因，**导致 rabbitmq 重启**，在 **RabbitMQ 重启期间生产者消息投递失败**， 导致**消息丢失**，需要**手动处理**和**恢复**。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特 别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢:

## 2. 发布确认 springboot 版本

### 1. 确认机制方案

> 当我们发布消息的时候，交换机宕机了，发送的消息无法保存，那么就会丢失，所以我们定义一个缓存来保存未成功发送的消息重新投递

![image-20220829163433119](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220829163433119.png)

### 2. 基本架构

> 正常情况下是能发送的，但是我们需要不正常的情况

![image-20220829163545590](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220829163545590.png)

### 3. 配置文件

**在配置文件当中需要添加 spring.rabbitmq.publisher-confirm-type=correlated**

 ⚫ NONE 禁用发布确认模式，是默认值 

⚫ CORRELATED 发布消息成功到交换器后会触发回调方法

⚫ SIMPLE    经测试有两种效果，其一效果和 CORRELATED 值一样会**触发回调方法**， 其二在发布消息成功后使用 rabbitTemplate 调用 **waitForConfirms 或 waitForConfirmsOrDie 方法 等待 broker 节点返回发送结果**，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker

### 4. 代码实现

#### 配置

```xml
spring.rabbitmq.publisher-confirm-type=correlate
```

#### 配置类

```java
@Configuration
public class TrueRabbitConfig {

    public static final String CONFIRM_EXCHANGE_NAME = "confirm.exchange";
    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";

    //配置交换机
    @Bean("confirmExchange")
    public DirectExchange confirmExchange (){
        return new DirectExchange(CONFIRM_EXCHANGE_NAME);
    }

    //配置队列
    @Bean("confirmQueue")
    public Queue confirmQueue(){
        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();
    }

    //进行绑定
    @Bean
    public Binding binding(@Qualifier("confirmQueue") Queue queue1,
                           @Qualifier("confirmExchange") DirectExchange directExchange1){
        return BindingBuilder.bind(queue1).to(directExchange1).with("key1");
    }


}

```

#### 生产者

```java
@RestController
@RequestMapping("true")
@Slf4j
public class TrueController {

    @Autowired
    RabbitTemplate rabbitTemplatel;

    @Autowired
    MyCallBack myCallBack;


    /**
     * 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。
     * PostConstruct在构造函数之后执行，init（）方法之前执行。
     */
    @PostConstruct
    public void init(){
        rabbitTemplatel.setConfirmCallback(myCallBack);

        /**
         * true:
         *交换机无法将消息进行路由时，会将该消息返回给生产者
         * false：
         *如果发现消息无法进行路由，则直接丢弃
                */
        rabbitTemplatel.setMandatory(true);

        rabbitTemplatel.setReturnsCallback(myCallBack);
    }


    @GetMapping("/sendMsg/{message}")
    public void sendMsg(@PathVariable String message){

        rabbitTemplatel.convertAndSend(TrueRabbitConfig.CONFIRM_EXCHANGE_NAME,"key132",message);

        log.info("生产者发送消息，消息为{}",message);

    }
}

```

#### 消费者

```java
@Component
@Slf4j
public class TrueConsumer {

    @RabbitListener(queues = TrueRabbitConfig.CONFIRM_QUEUE_NAME)
    public void receive(Message message){
        String messages = new String(message.getBody());
        log.info("队列成功接收消息，消息为{}",messages);

    }

}
```

#### 交换机回调函数

> 当就交换机宕机或者成功的时候，就进行调用，但是启动前需要配置文件，上面已写

```java
/**
 * 交换机回调
 */
@Component
@Slf4j
public class MyCallBack implements RabbitTemplate.ConfirmCallback ,RabbitTemplate.ReturnsCallback {

    /*
    * 米米
    * 交换机确认回调方法
    *1.发消息交换机接收到了回调
            1.1 correlationData   保存回凋消息的ID及相关信息
            1.2交换机收到消息ack=true
            1.3 cause null
     *2.发消息交换机接收失败了回调
            2.1 correlationData保存回凋消息的ID及相关信息
            2.2交换机收到消息ack=fa1se
            2.3 cause 消息
    * */
    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {


            //String id = correlationData.getId()==null?correlationData.getId():" ";

             String id=correlationData!=null?correlationData.getId():"";

        //成功
            if(ack){
                log.info("交换机成功接收消息，消息id为{}",id);
            }else { //为false
                log.info("交换机接收消息失败，消息id为{}，错误原因：{}",id,cause);
            }
    }


    /**
     * 队列接收失败提示信息
     * @param message
     * @param replyCode
     * @param replyText
     * @param exchange
     * @param routingKey
     */
    @Override
    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {

        log.error(" 消 息 {}, 被 交 换 机 {} 退 回 ， 退 回 原 因 :{}, 路 由 key:{}",new
                String(message.getBody()),exchange,replyText,routingKey);
    }

    @Override
    public void returnedMessage(ReturnedMessage message) {
        log.error("消息{},被交换机{}退回,退出原因：{}，路由key:{}",
                new String(message.getMessage().toString()),message.getExchange().toString(),message.getReplyText(),message.getRoutingKey());
    }
}

```

#### 消息队列回调

上面代码已实现

主要是用来解决消息代码宕机的时候接收的信息

## 3.备份交换机

### 1. 基本概念

备份 交换机可以理解为 **RabbitMQ 中交换机的“备胎”**，当我们为某一个交换机声明一个对应的备份交换机时，就 是为它创建一个备胎，当**交换机接收到一条不可路由消息时**，将会把**这条消息转发到备份交换机中**，由**备 份交换机来进行转发和处理**，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定 的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。

### 2. 基本架构

![image-20220830075204069](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220830075204069.png)

### 3. 代码实现

#### 配置类

```java
/**
 * 配置类
 */
@Configuration
public class TrueRabbitConfig {

    public static final String CONFIRM_EXCHANGE_NAME = "confirm.exchange";
    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";
    //备份交换机
    public static final String BACKUP_EXCHANGE_NAME ="backup.exchange";
    //备份队列
    public static final String BACKUP_QUEUE_NAME = "backup.queue";
    //警告队列
    public static final String WARNING_QUEUE_NAME="warning.queue";


    //配置交换机
    @Bean("confirmExchange")
    public DirectExchange confirmExchange (){
        //指定备份交换机
        return ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(true).
                withArgument("alternate-exchange",BACKUP_EXCHANGE_NAME).build();
    }
    //配置备份交换机
    @Bean("backupExchange")
    public FanoutExchange backupExchange(){
        return new FanoutExchange(BACKUP_EXCHANGE_NAME);
    }

    //配置备份队列
    @Bean("backupQueue")
    public Queue backupQueue(){
        return new Queue(BACKUP_QUEUE_NAME);
    }

    //配置警告队列
    @Bean("warningQueue")
    public Queue warningQueue(){
        return new Queue(WARNING_QUEUE_NAME);
    }


    //配置队列
    @Bean("confirmQueue")
    public Queue confirmQueue(){
        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();
    }

    //进行绑定
    @Bean
    public Binding binding(@Qualifier("confirmQueue") Queue queue1,
                           @Qualifier("confirmExchange") DirectExchange directExchange1){
        return BindingBuilder.bind(queue1).to(directExchange1).with("key1");
    }


    //备份队列进行绑定
    @Bean
    public Binding binding1(@Qualifier("backupQueue") Queue queue,
                            @Qualifier("backupExchange") FanoutExchange exchange){

        return BindingBuilder.bind(queue).to(exchange);
    }

    //警告队列进行绑定
    @Bean
    public Binding binding2(@Qualifier("warningQueue") Queue queue,
                            @Qualifier("backupExchange") FanoutExchange exchange){
        return BindingBuilder.bind(queue).to(exchange);
    }


}
```

#### 生产者

```java
@RestController
@RequestMapping("true")
@Slf4j
public class TrueController {

    @Autowired
    RabbitTemplate rabbitTemplatel;

    @Autowired
    MyCallBack myCallBack;


    /**
     * 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。
     * PostConstruct在构造函数之后执行，init（）方法之前执行。
     */
    @PostConstruct
    public void init(){
        rabbitTemplatel.setConfirmCallback(myCallBack);

        /**
         * true:
         *交换机无法将消息进行路由时，会将该消息返回给生产者
         * false：
         *如果发现消息无法进行路由，则直接丢弃
                */
        rabbitTemplatel.setMandatory(true);

        rabbitTemplatel.setReturnsCallback(myCallBack);
    }


    @GetMapping("/sendMsg/{message}")
    public void sendMsg(@PathVariable String message){

        rabbitTemplatel.convertAndSend(TrueRabbitConfig.CONFIRM_EXCHANGE_NAME,"key132",message);

        log.info("生产者发送消息，消息为{}",message);

    }
}

```

#### 备份消费者

```java
@Component
@Slf4j
public class BackupConsumer {


    //TODO 测试
    @RabbitListener(queues = TrueRabbitConfig.BACKUP_QUEUE_NAME)
    public void recevie(Message message){
        String msg = new String(message.getBody());
        log.info("备份交换机成功接收到，消息为{}",msg);
    }
}
```

#### 警告费者

```java
@Component
@Slf4j
public class WarningConsumer {

    @RabbitListener(queues = TrueRabbitConfig.WARNING_QUEUE_NAME)
    public void receive(Message message){
        String msg = new String(message.getBody());

        log.error("{}消息出现异常，被警告交换机接收到",msg);

    }
}
```

### 4.结果分析

mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先 级高，经过上面结果显示答案是备份**交换机优先级高**。

# 11. RabbitMQ 其他知识点 

## 1. 幂等性

### 1.1概念

RabbitMQ中的幂等性又是什么意思呢？我们先来看看在RabbitMQ中，哪些情况可能导致非幂等？

① consumer接收到消息处理完成后，在给Broker返回ack途中网络中断，Broker未收到确认信息，根据RabbitMQ的重试补偿机制，则会把这条消息再重发给其他的消费者或等网络重连后再发送给该消费者，造成了消息的重复消费。

② 或者在开启生产者confirm模式下，生产者已经把消息发送到Broker，但在Broker回传ack确认时网络中断，生产者也会重新发送刚才的消息，造成Broker收到了重复的消息，最终将两条重复的消息发送到消费端，造成了消息的重复消费。

通过以上两种场景我们看出，其实MQ的幂等性保障应该在消费端，要保证MQ的幂等性，就要保证消费者不会重复消费相同的消息。


### 1.2 解决办法

**全局唯一ID + Redis**

全局唯一ID + Redis

生产者在发送消息时，为每条消息设置一个全局唯一的messageId，消费者拿到消息后，使用setnx命令，将messageId作为key放到redis中：setnx(messageId,1)，**若返回1**，说明之前没有消费过，**正常消费**；**若返回0**，说明**这条消息之前已消费过，抛弃**。

※ setnx命令，若给定的key不存在，执行set操作，返回1，若给定的Key已存在，不做任何操作，返回0。

> 生产者代码

```java
public void sendMessageIde() {
    MessageProperties properties = new MessageProperties();
    properties.setMessageId(UUID.randomUUID().toString());
    Message message = new Message("Hello RabbitMQ".getBytes(), properties);
    //存入到redis中
    rabbitTemplate.convertAndSend("durable-exchange", "rabbit.long.yuan", message);
}
```



> 消费者代码

```java
@RabbitListener(queues = "durable-queue")
@RabbitHandler
public void processIde(Message message, Channel channel) throws IOException {

if (stringRedisTemplate.opsForValue().setIfAbsent(message.getMessageProperties().getMessageId(),"1")){
    // 业务操作...
    System.out.println("消费消息："+ new String(message.getBody(), "UTF-8"));
 
    // 手动确认
    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
}
```

## 2. 优先级队列

### 背景

RabbitMQ 自 V3.5.0 有优先级队列实现。使用客户端提供的可选参数可将任何队列转换为优先级（但与使用可选参数而不是策略的其他功能不同）。其实现支持有限数量的优先事项：255。但推荐值介于： 1 ~ 10。

> 就是在创建的时候指定队列的优先级个数，在发消息的时候指定消息的优先级

### 代码

#### 队列指定优先级

## 3. 惰性队列

惰性队列会尽可能的将消息存入磁盘中，而在消 费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持 更多的消息存储。

> 就是将消息存入都磁盘中

### 1. 代码

> 在定义队列的时候添加

```java
Map<String, Object> args = new HashMap<String, Object>();
args.put("x-queue-mode", "lazy");
channel.queueDeclare("myqueue", false, false, false, args)
```

# 12. RabbitMQ 集群

## 10.1. clustering

### 10.1.1. 使用集群的原因 

如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？

购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是 解决实际问题的关键.

### 10.1.2. 搭建步骤

1.修改 3 台机器的主机名称 node1, node2,node3

```
vim /etc/hostname
```

 2.配置各个节点的 hosts 文件，让各个节点都能互相识别对方 

```
vim /etc/hosts 
10.211.55.74 node1
10.211.55.75 node2 
10.211.55.76 node3 
```

3.以确保各个节点的 cookie 文件使用的是同一个值 在 node1 上执行远程操作命令 

```
scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie
scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie 
```

4.启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以 下命令) 

```
rabbitmq-server -detached
```

 5.在节点 2 执行

```
 rabbitmqctl stop_app (rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务) 

rabbitmqctl reset 

rabbitmqctl join_cluster rabbit@node1 

rabbitmqctl start_app(只启动应用服务) 
```

6.在节点 3 执行

```
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl join_cluster rabbit@node2
rabbitmqctl start_app
```

7.集群状态 

> 任何结点都可执行

```
rabbitmqctl cluster_status 
```

8.需要重新设置用户 

```
创建账号 rabbitmqctl add_user admin 123 

设置用户角色 rabbitmqctl set_user_tags admin administrator 

设置用户权限 rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*" 
```

9.解除集群节点(node2 和 node3 机器分别执行) 

```
rabbitmqctl stop_app 

rabbitmqctl reset 

rabbitmqctl start_app 

rabbitmqctl cluster_status rabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行）
```

## 10.2. 镜像队列 

### 10.2.1使用镜像队列的原因

我们搭建了rabbitMQ的集群，但是他们的队列和并不共享，所以当node1宕机，那么他的消息就会消失，并不会在node2或node3有，为了解决这个问题，我们引入了镜像队列。

他相当于是把node1的队列全都备份到node2和node3中去

### 10.2.2 搭建步骤

1.启动三台集群节点 

2.随便找一个节点添加 policy 
![image-20220831144227639](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220831144227639.png)

3.在 node1 上创建一个队列发送一条消息，队列存在镜像队列 
![image-20220831144252590](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220831144252590.png)

4.停掉 node1 之后发现 node2 成为镜像队列 引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中 的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。 

![image-20220831144313408](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220831144313408.png)

## 10.3. Haproxy+Keepalive 实现高可用负载均衡

### 10.3.1  使用他的原因

我们在镜像中，如果我们换掉其他的rabbitMQ来进行替代，那么就要手动的进行一个ip更换，这在开发中是不允许存在的。

为了解决这个问题，**我们使用了Haproxy**,可以实现这个自动更换

也可以使用Nginx来自动更换

### 10.3.2 原理

![image-20220831144554893](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220831144554893.png)

### 10.3.3 实现步骤

1. 下载 haproxy(在 node1 和 node2) yum -y install haproxy

2. 修改 node1 和 node2 的 haproxy.cfg

	```
	vim /etc/haproxy/haproxy.cfg
	```

	需要修改红色 IP 为当前机器 IP
	![image-20220831144724004](C:\Users\覃江才\AppData\Roaming\Typora\typora-user-images\image-20220831144724004.png)

3. 在两台节点启动 haproxy

	```
	haproxy -f /etc/haproxy/haproxy.cfg
	ps -ef | grep haproxy
	```

	```
	Created directory 'C:\Users\userpath\.ssh'.
	```

	

